/**
 * Marlin 3D Printer Firmware
 * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

/**
 * stepper_indirection.h - stepper motor driver indirection macros
 * to allow some stepper functions to be done via SPI/I2c instead of direct pin manipulation
 * Part of Marlin
 *
 * Copyright (c) 2015 Dominik Wenger
 *
 * Marlin is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * at your option) any later version.
 *
 * Marlin is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Marlin.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "../inc/MarlinConfig.h"

// TMC26X drivers have STEP/DIR on normal pins, but ENABLE via SPI
#if HAS_DRIVER(TMC26X)
  #include <SPI.h>
  #ifdef STM32F7
    #include "../HAL/HAL_STM32F7/TMC2660.h"
  #else
    #include <TMC26XStepper.h>
  #endif
  void tmc26x_init_to_defaults();
#endif

#if HAS_TRINAMIC
  #include <TMCStepper.h>
  #include "../feature/tmc_util.h"
  #if TMCSTEPPER_VERSION < 0x000202
    #error "Update TMCStepper library to 0.2.2 or newer."
  #endif

  #define ____TMC_CLASS(MODEL, A, I) TMCMarlin<TMC##MODEL##Stepper, A, I>
  #define ___TMC_CLASS(MODEL, A, I) ____TMC_CLASS(MODEL, A, I)
  #define __TMC_CLASS(MODEL, A, I) ___TMC_CLASS(_##MODEL, A, I)
  #define _TMC_CLASS(MODEL, L) __TMC_CLASS(MODEL, L)
  #define TMC_CLASS(ST) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL)

  typedef struct {
    uint8_t toff;
    int8_t hend;
    uint8_t hstrt;
  } chopper_timing_t;

  static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;

  #if HAS_DRIVER(TMC2208)
    void tmc2208_serial_begin();
  #endif
#endif

void restore_stepper_drivers();  // Called by PSU_ON
void reset_stepper_drivers();    // Called by settings.load / settings.reset

// Driver models
#define _A4988_MODEL_REFERENCE(AXIS) 
#define _A4988_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
#define _A4988_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
#define _A4988_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
#define _A4988_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
#define _A4988_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
#define _A4988_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
#define _A4988_MODEL_DIR_CHANGE_DELAY 200
#define _A4988_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
#define _A4988_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
#define _A4988_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
#define _A4988_MODEL_STEP_SECOND_PHASE_NEED true
#define _A4988_MODEL_STEP_FIRST_PHASE_WIDTH 1
#define _A4988_MODEL_STEP_SECOND_PHASE_WIDTH 1
#if HAS_DRIVER(A5984)
  #define _A5984_MODEL_REFERENCE(AXIS) 
  #define _A5984_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _A5984_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _A5984_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _A5984_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _A5984_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _A5984_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _A5984_MODEL_DIR_CHANGE_DELAY 400
  #define _A5984_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _A5984_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _A5984_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _A5984_MODEL_STEP_SECOND_PHASE_NEED true
  #define _A5984_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _A5984_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(DRV8825)
  #define _DRV8825_MODEL_REFERENCE(AXIS) 
  #define _DRV8825_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _DRV8825_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _DRV8825_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _DRV8825_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _DRV8825_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _DRV8825_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _DRV8825_MODEL_DIR_CHANGE_DELAY 650
  #define _DRV8825_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _DRV8825_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _DRV8825_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _DRV8825_MODEL_STEP_SECOND_PHASE_NEED true
  #define _DRV8825_MODEL_STEP_FIRST_PHASE_WIDTH 2
  #define _DRV8825_MODEL_STEP_SECOND_PHASE_WIDTH 2
#endif
#if HAS_DRIVER(LV8729)
  #define _LV8729_MODEL_REFERENCE(AXIS) 
  #define _LV8729_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _LV8729_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _LV8729_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _LV8729_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _LV8729_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _LV8729_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _LV8729_MODEL_DIR_CHANGE_DELAY 500
  #define _LV8729_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _LV8729_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _LV8729_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _LV8729_MODEL_STEP_SECOND_PHASE_NEED true
  #define _LV8729_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _LV8729_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(L6470)
  // L6470 has STEP on normal pins, but DIR/ENABLE via SPI
  #include "L6470/L6470_Marlin.h"
  #define L6470_WRITE_DIR_COMMAND(STATE,Q) do{ L6470_dir_commands[Q] = (STATE ?  dSPIN_STEP_CLOCK_REV : dSPIN_STEP_CLOCK_FWD); }while(0)

  #define _L6470_MODEL_REFERENCE(AXIS) extern L6470 stepper##AXIS
  #define _L6470_MODEL_ENABLE_INIT(AXIS) NOOP
  #define _L6470_MODEL_ENABLE_WRITE(AXIS, STATE) NOOP
  #define _L6470_MODEL_ENABLE_READ(AXIS) (stepper##AXIS##.getStatus() & STATUS_HIZ)
  #define _L6470_MODEL_DIR_INIT(AXIS) NOOP
  #define _L6470_MODEL_DIR_WRITE(AXIS, STATE) L6470_WRITE_DIR_COMMAND(STATE,AXIS)
  #define _L6470_MODEL_DIR_READ(AXIS) (stepper##AXIS.getStatus() & STATUS_DIR)
  #define _L6470_MODEL_DIR_CHANGE_DELAY 0
  #define _L6470_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _L6470_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _L6470_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _L6470_MODEL_STEP_SECOND_PHASE_NEED true
  #define _L6470_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _L6470_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(TB6560)
  #define _TB6560_MODEL_REFERENCE(AXIS) 
  #define _TB6560_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TB6560_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TB6560_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TB6560_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TB6560_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TB6560_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _TB6560_MODEL_DIR_CHANGE_DELAY 15000
  #define _TB6560_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TB6560_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TB6560_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TB6560_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TB6560_MODEL_STEP_FIRST_PHASE_WIDTH 30
  #define _TB6560_MODEL_STEP_SECOND_PHASE_WIDTH 30
#endif
#if HAS_DRIVER(TB6600)
  #define _TB6600_MODEL_REFERENCE(AXIS) 
  #define _TB6600_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TB6600_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TB6600_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TB6600_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TB6600_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TB6600_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _TB6600_MODEL_DIR_CHANGE_DELAY 1500
  #define _TB6600_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TB6600_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TB6600_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TB6600_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TB6600_MODEL_STEP_FIRST_PHASE_WIDTH 3
  #define _TB6600_MODEL_STEP_SECOND_PHASE_WIDTH 3
#endif
#if HAS_DRIVER(TMC2100)
  #define _TMC2100_MODEL_REFERENCE(AXIS) 
  #define _TMC2100_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2100_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2100_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2100_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2100_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2100_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2100_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2100_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2100_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2100_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2100_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2100_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2100_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2130)
  #define __TMC2130_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2130_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2130_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2130_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2130_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2130_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2130_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2130_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2130_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2130_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2130_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2130_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2130_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2130_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2130_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2130_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2130_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2130_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2130_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2130_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2130_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2130_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2130_STANDALONE)
  #define _TMC2130_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2130_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2130_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2130_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2130_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2130_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2130_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2130_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2160)
  #define __TMC2160_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2160_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2160_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2160_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2160_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2160_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2160_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2160_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2160_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2160_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2160_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2160_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2160_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2160_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2160_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2160_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2160_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2160_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2160_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2160_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2160_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2160_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2160_STANDALONE)
  #define _TMC2160_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2160_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2160_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2160_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2160_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2160_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2160_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2160_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2208)
  #define __TMC2208_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2208_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2208_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2208_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2208_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2208_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2208_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2208_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2208_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2208_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2208_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2208_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2208_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2208_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2208_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2208_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2208_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2208_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2208_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2208_STANDALONE)
  #define _TMC2208_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2208_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2208_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2208_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2208_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2208_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2208_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2208_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC26X)
  #define _TMC26X_MODEL_REFERENCE(AXIS) extern TMC26XStepper stepper##AXIS
  #define _TMC26X_MODEL_ENABLE_INIT(AXIS) NOOP
  #define _TMC26X_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.setEnabled(STATE)
  #define _TMC26X_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #define _TMC26X_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC26X_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC26X_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC26X_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC26X_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC26X_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC26X_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC26X_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC26X_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC26X_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC26X_STANDALONE)
  #define _TMC26X_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC26X_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC26X_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC26X_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC26X_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC26X_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC26X_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC26X_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2660)
  #define __TMC2660_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2660_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2660_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2660_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2660_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2660_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2660_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2660_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2660_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2660_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2660_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2660_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2660_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2660_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2660_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2660_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2660_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2660_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2660_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2660_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2660_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2660_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2660_STANDALONE)
  #define _TMC2660_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2660_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2660_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2660_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2660_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2660_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2660_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2660_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5130)
  #define __TMC5130_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC5130_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC5130_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC5130_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC5130_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC5130_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC5130_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC5130_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC5130_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC5130_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5130_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5130_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5130_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5130_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC5130_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC5130_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC5130_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC5130_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC5130_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC5130_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC5130_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5130_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5130_STANDALONE)
  #define _TMC5130_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC5130_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC5130_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5130_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC5130_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC5130_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC5130_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5130_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5160)
  #define __TMC5160_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC5160_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC5160_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC5160_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC5160_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC5160_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC5160_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC5160_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC5160_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC5160_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5160_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5160_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5160_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5160_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC5160_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC5160_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC5160_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC5160_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC5160_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC5160_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC5160_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5160_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5160_STANDALONE)
  #define _TMC5160_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC5160_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC5160_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5160_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC5160_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC5160_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC5160_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5160_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif

// Utility driver models macro
#ifdef X_DRIVER_TYPE
  #define ___X_DRIVER_TYPE X_DRIVER_TYPE
#else
  #define ___X_DRIVER_TYPE A4988
#endif
#ifdef Y_DRIVER_TYPE
  #define ___Y_DRIVER_TYPE Y_DRIVER_TYPE
#else
  #define ___Y_DRIVER_TYPE A4988
#endif
#ifdef Z_DRIVER_TYPE
  #define ___Z_DRIVER_TYPE Z_DRIVER_TYPE
#else
  #define ___Z_DRIVER_TYPE A4988
#endif
#ifdef X2_DRIVER_TYPE
  #define ___X2_DRIVER_TYPE X2_DRIVER_TYPE
#else
  #define ___X2_DRIVER_TYPE A4988
#endif
#ifdef Y2_DRIVER_TYPE
  #define ___Y2_DRIVER_TYPE Y_DRIVER_TYPE
#else
  #define ___Y2_DRIVER_TYPE A4988
#endif
#ifdef Z2_DRIVER_TYPE
  #define ___Z2_DRIVER_TYPE Z2_DRIVER_TYPE
#else
  #define ___Z2_DRIVER_TYPE A4988
#endif
#ifdef Z3_DRIVER_TYPE
  #define ___Z3_DRIVER_TYPE Z3_DRIVER_TYPE
#else
  #define ___Z3_DRIVER_TYPE A4988
#endif

#define _GET_AXIS_DRIVER_TYPE(AXIS) ___##AXIS##_DRIVER_TYPE
#define ___DRIVER_REFERENCE(TYPE) _ ## TYPE ## _MODEL_REFERENCE
#define ___MODEL_MACRO_NAME(TYPE, A, B) _ ## TYPE ## _MODEL_ ## A ## _ ## B
#ifdef MINIMUM_STEPPER_DIR_DELAY
  #define ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(DELAY) MAX(DELAY, MINIMUM_STEPPER_DIR_DELAY)
#else
  #define ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(DELAY) DELAY
#endif

#define __DRIVER_REFERENCE(TYPE, AXIS) ___DRIVER_REFERENCE(TYPE)(AXIS)
#define __DRIVER_ENABLE_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, ENABLE, INIT)(AXIS)
#define __DRIVER_ENABLE_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, ENABLE, WRITE)(AXIS, STATE)
#define __DRIVER_ENABLE_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, ENABLE, READ)(AXIS)
#define __DRIVER_DIR_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, INIT)(AXIS)
#define __DRIVER_DIR_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, DIR, WRITE)(AXIS, STATE)
#define __DRIVER_DIR_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, READ)(AXIS)
#define __DRIVER_DIR_CHANGE_DELAY(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, CHANGE_DELAY)
#define __DRIVER_STEP_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, STEP, INIT)(AXIS)
#define __DRIVER_STEP_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, STEP, WRITE)(AXIS, STATE)
#define __DRIVER_STEP_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, STEP, READ)(AXIS)
#define __DRIVER_STEP_FIRST_PHASE_WIDTH(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, FIRST_PHASE_WIDTH)
#define __DRIVER_STEP_SECOND_PHASE_WIDTH(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, SECOND_PHASE_WIDTH)
#define __DRIVER_STEP_SECOND_PHASE_NEED(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, SECOND_PHASE_NEED)

#define _DRIVER_REFERENCE(AXIS) __DRIVER_REFERENCE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_ENABLE_INIT(AXIS) __DRIVER_ENABLE_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_ENABLE_WRITE(AXIS, STATE) __DRIVER_ENABLE_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, STATE)
#define _DRIVER_ENABLE_READ(AXIS) __DRIVER_ENABLE_READ(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_INIT(AXIS) __DRIVER_DIR_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_WRITE(AXIS, STATE) __DRIVER_DIR_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, STATE)
#define _DRIVER_DIR_READ(AXIS) __DRIVER_DIR_READ(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_CHANGE_DELAY(AXIS) ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(__DRIVER_DIR_CHANGE_DELAY(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS))
#define _DRIVER_STEP_INIT(AXIS) __DRIVER_STEP_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_STEP_WRITE(AXIS, STATE) __DRIVER_STEP_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, STATE)
#define _DRIVER_STEP_READ(AXIS) __DRIVER_STEP_READ(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_STEP_FIRST_PHASE_WIDTH(AXIS) __DRIVER_STEP_FIRST_PHASE_WIDTH(_GET_AXIS_DRIVER_TYPE(AXIS))
#define _DRIVER_STEP_SECOND_PHASE_WIDTH(AXIS) __DRIVER_STEP_SECOND_PHASE_WIDTH(_GET_AXIS_DRIVER_TYPE(AXIS))
#define _DRIVER_STEP_SECOND_PHASE_NEED(AXIS) __DRIVER_STEP_SECOND_PHASE_NEED(_GET_AXIS_DRIVER_TYPE(AXIS))

// X Stepper
#define X_DRIVER_REFERENCE _DRIVER_REFERENCE(X)
#define X_ENABLE_INIT _DRIVER_ENABLE_INIT(X)
#define X_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(X, STATE)
#define X_ENABLE_READ _DRIVER_ENABLE_READ(X)
#define X_DIR_INIT _DRIVER_DIR_INIT(X)
#define X_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(X, STATE)
#define X_DIR_READ _DRIVER_DIR_READ(X)
#define X_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(X)
#define X_STEP_INIT _DRIVER_STEP_INIT(X)
#define X_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(X, STATE)
#define X_STEP_READ _DRIVER_STEP_READ(X)
#define X_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(X)
#define X_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(X)
#define X_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(X)
X_DRIVER_REFERENCE;

// Y Stepper
#define Y_DRIVER_REFERENCE _DRIVER_REFERENCE(Y)
#define Y_ENABLE_INIT _DRIVER_ENABLE_INIT(Y)
#define Y_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Y, STATE)
#define Y_ENABLE_READ _DRIVER_ENABLE_READ(Y)
#define Y_DIR_INIT _DRIVER_DIR_INIT(Y)
#define Y_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Y, STATE)
#define Y_DIR_READ _DRIVER_DIR_READ(Y)
#define Y_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Y)
#define Y_STEP_INIT _DRIVER_STEP_INIT(Y)
#define Y_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(Y, STATE)
#define Y_STEP_READ _DRIVER_STEP_READ(Y)
#define Y_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Y)
#define Y_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Y)
#define Y_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Y)
Y_DRIVER_REFERENCE;

// Z Stepper
#define Z_DRIVER_REFERENCE _DRIVER_REFERENCE(Z)
#define Z_ENABLE_INIT _DRIVER_ENABLE_INIT(Z)
#define Z_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z, STATE)
#define Z_ENABLE_READ _DRIVER_ENABLE_READ(Z)
#define Z_DIR_INIT _DRIVER_DIR_INIT(Z)
#define Z_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z, STATE)
#define Z_DIR_READ _DRIVER_DIR_READ(Z)
#define Z_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z)
#define Z_STEP_INIT _DRIVER_STEP_INIT(Z)
#define Z_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(Z, STATE)
#define Z_STEP_READ _DRIVER_STEP_READ(Z)
#define Z_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z)
#define Z_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z)
#define Z_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z)
Z_DRIVER_REFERENCE;

// X2 Stepper
#if HAS_X2_ENABLE
  #define X2_DRIVER_REFERENCE _DRIVER_REFERENCE(X2)
  #define X2_ENABLE_INIT _DRIVER_ENABLE_INIT(X2)
  #define X2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(X2, STATE)
  #define X2_ENABLE_READ _DRIVER_ENABLE_READ(X2)
  #define X2_DIR_INIT _DRIVER_DIR_INIT(X2)
  #define X2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(X2, STATE)
  #define X2_DIR_READ _DRIVER_DIR_READ(X2)
  #define X2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(X2)
  #define X2_STEP_INIT _DRIVER_STEP_INIT(X2)
  #define X2_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(X2, STATE)
  #define X2_STEP_READ _DRIVER_STEP_READ(X2)
  #define X2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(X2)
  #define X2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(X2)
  #define X2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(X2)
  X2_DRIVER_REFERENCE;
#endif

// Y2 Stepper
#if HAS_Y2_ENABLE
  #define Y2_DRIVER_REFERENCE _DRIVER_REFERENCE(Y2)
  #define Y2_ENABLE_INIT _DRIVER_ENABLE_INIT(Y2)
  #define Y2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Y2, STATE)
  #define Y2_ENABLE_READ _DRIVER_ENABLE_READ(Y2)
  #define Y2_DIR_INIT _DRIVER_DIR_INIT(Y2)
  #define Y2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Y2, STATE)
  #define Y2_DIR_READ _DRIVER_DIR_READ(Y2)
  #define Y2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Y2)
  #define Y2_STEP_INIT _DRIVER_STEP_INIT(Y2)
  #define Y2_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(Y2, STATE)
  #define Y2_STEP_READ _DRIVER_STEP_READ(Y2)
  #define Y2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Y2)
  #define Y2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Y2)
  #define Y2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Y2)
  Y2_DRIVER_REFERENCE;
#else
  #define Y2_DIR_WRITE(STATE) NOOP
#endif

// Z2 Stepper
#if HAS_Z2_ENABLE
  #define Z2_DRIVER_REFERENCE _DRIVER_REFERENCE(Z2)
  #define Z2_ENABLE_INIT _DRIVER_ENABLE_INIT(Z2)
  #define Z2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z2, STATE)
  #define Z2_ENABLE_READ _DRIVER_ENABLE_READ(Z2)
  #define Z2_DIR_INIT _DRIVER_DIR_INIT(Z2)
  #define Z2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z2, STATE)
  #define Z2_DIR_READ _DRIVER_DIR_READ(Z2)
  #define Z2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z2)
  #define Z2_STEP_INIT _DRIVER_STEP_INIT(Z2)
  #define Z2_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(Z2, STATE)
  #define Z2_STEP_READ _DRIVER_STEP_READ(Z2)
  #define Z2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z2)
  #define Z2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z2)
  #define Z2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z2)
  Z2_DRIVER_REFERENCE;
#else
  #define Z2_DIR_WRITE(STATE) NOOP
#endif

// Z3 Stepper
#if HAS_Z3_ENABLE
  #define Z3_DRIVER_REFERENCE _DRIVER_REFERENCE(Z3)
  #define Z3_ENABLE_INIT _DRIVER_ENABLE_INIT(Z3)
  #define Z3_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z3, STATE)
  #define Z3_ENABLE_READ _DRIVER_ENABLE_READ(Z3)
  #define Z3_DIR_INIT _DRIVER_DIR_INIT(Z3)
  #define Z3_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z3, STATE)
  #define Z3_DIR_READ _DRIVER_DIR_READ(Z3)
  #define Z3_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z3)
  #define Z3_STEP_INIT _DRIVER_STEP_INIT(Z3)
  #define Z3_STEP_WRITE(STATE) _DRIVER_STEP_WRITE(Z3, STATE)
  #define Z3_STEP_READ _DRIVER_STEP_READ(Z3)
  #define Z3_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z3)
  #define Z3_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z3)
  #define Z3_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z3)
  Z3_DRIVER_REFERENCE;
#else
  #define Z3_DIR_WRITE(STATE) NOOP
#endif

// E0 Stepper
#if AXIS_DRIVER_TYPE_E0(L6470)
  extern L6470 stepperE0;
  #define E0_ENABLE_INIT NOOP
  #define E0_ENABLE_WRITE(STATE) NOOP
  #define E0_ENABLE_READ (stepperE0.getStatus() & STATUS_HIZ)
  #define E0_DIR_INIT NOOP
  #define E0_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E0)
  #define E0_DIR_READ (stepperE0.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E0)
    extern TMC_CLASS(E0) stepperE0;
  #endif
  #if AXIS_DRIVER_TYPE_E0(TMC26X)
    extern TMC26XStepper stepperE0;
    #define E0_ENABLE_INIT NOOP
    #define E0_ENABLE_WRITE(STATE) stepperE0.setEnabled(STATE)
    #define E0_ENABLE_READ stepperE0.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
    #define E0_ENABLE_INIT NOOP
    #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E0_ENABLE_READ stepperE0.isEnabled()
  #else
    #define E0_ENABLE_INIT SET_OUTPUT(E0_ENABLE_PIN)
    #define E0_ENABLE_WRITE(STATE) WRITE(E0_ENABLE_PIN,STATE)
    #define E0_ENABLE_READ READ(E0_ENABLE_PIN)
  #endif
  #define E0_DIR_INIT SET_OUTPUT(E0_DIR_PIN)
  #define E0_DIR_WRITE(STATE) WRITE(E0_DIR_PIN,STATE)
  #define E0_DIR_READ READ(E0_DIR_PIN)
#endif
#define E0_STEP_INIT SET_OUTPUT(E0_STEP_PIN)
#if AXIS_IS_TMC(E0) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E0_STEP_WRITE(STATE) if (STATE) { TOGGLE(E0_STEP_PIN); }
#else
  #define E0_STEP_WRITE(STATE) WRITE(E0_STEP_PIN,STATE)
  #define E0_STEP_READ READ(E0_STEP_PIN)
#endif

// E1 Stepper
#if AXIS_DRIVER_TYPE_E1(L6470)
  extern L6470 stepperE1;
  #define E1_ENABLE_INIT NOOP
  #define E1_ENABLE_WRITE(STATE) NOOP
  #define E1_ENABLE_READ (stepperE1.getStatus() & STATUS_HIZ)
  #define E1_DIR_INIT NOOP
  #define E1_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E1)
  #define E1_DIR_READ (stepperE1.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E1)
    extern TMC_CLASS(E1) stepperE1;
  #endif
  #if AXIS_DRIVER_TYPE_E1(TMC26X)
    extern TMC26XStepper stepperE1;
    #define E1_ENABLE_INIT NOOP
    #define E1_ENABLE_WRITE(STATE) stepperE1.setEnabled(STATE)
    #define E1_ENABLE_READ stepperE1.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
    #define E1_ENABLE_INIT NOOP
    #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E1_ENABLE_READ stepperE1.isEnabled()
  #else
    #define E1_ENABLE_INIT SET_OUTPUT(E1_ENABLE_PIN)
    #define E1_ENABLE_WRITE(STATE) WRITE(E1_ENABLE_PIN,STATE)
    #define E1_ENABLE_READ READ(E1_ENABLE_PIN)
  #endif
  #define E1_DIR_INIT SET_OUTPUT(E1_DIR_PIN)
  #define E1_DIR_WRITE(STATE) WRITE(E1_DIR_PIN,STATE)
  #define E1_DIR_READ READ(E1_DIR_PIN)
#endif
#define E1_STEP_INIT SET_OUTPUT(E1_STEP_PIN)
#if AXIS_IS_TMC(E1) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E1_STEP_WRITE(STATE) if (STATE) { TOGGLE(E1_STEP_PIN); }
#else
  #define E1_STEP_WRITE(STATE) WRITE(E1_STEP_PIN,STATE)
  #define E1_STEP_READ READ(E1_STEP_PIN)
#endif

// E2 Stepper
#if AXIS_DRIVER_TYPE_E2(L6470)
  extern L6470 stepperE2;
  #define E2_ENABLE_INIT NOOP
  #define E2_ENABLE_WRITE(STATE) NOOP
  #define E2_ENABLE_READ (stepperE2.getStatus() & STATUS_HIZ)
  #define E2_DIR_INIT NOOP
  #define E2_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E2)
  #define E2_DIR_READ (stepperE2.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E2)
    extern TMC_CLASS(E2) stepperE2;
  #endif
  #if AXIS_DRIVER_TYPE_E2(TMC26X)
    extern TMC26XStepper stepperE2;
    #define E2_ENABLE_INIT NOOP
    #define E2_ENABLE_WRITE(STATE) stepperE2.setEnabled(STATE)
    #define E2_ENABLE_READ stepperE2.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
    #define E2_ENABLE_INIT NOOP
    #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E2_ENABLE_READ stepperE2.isEnabled()
  #else
    #define E2_ENABLE_INIT SET_OUTPUT(E2_ENABLE_PIN)
    #define E2_ENABLE_WRITE(STATE) WRITE(E2_ENABLE_PIN,STATE)
    #define E2_ENABLE_READ READ(E2_ENABLE_PIN)
  #endif
  #define E2_DIR_INIT SET_OUTPUT(E2_DIR_PIN)
  #define E2_DIR_WRITE(STATE) WRITE(E2_DIR_PIN,STATE)
  #define E2_DIR_READ READ(E2_DIR_PIN)
#endif
#define E2_STEP_INIT SET_OUTPUT(E2_STEP_PIN)
#if AXIS_IS_TMC(E2) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E2_STEP_WRITE(STATE) if (STATE) { TOGGLE(E2_STEP_PIN); }
#else
  #define E2_STEP_WRITE(STATE) WRITE(E2_STEP_PIN,STATE)
  #define E2_STEP_READ READ(E2_STEP_PIN)
#endif

// E3 Stepper
#if AXIS_DRIVER_TYPE_E3(L6470)
  extern L6470 stepperE3;
  #define E3_ENABLE_INIT NOOP
  #define E3_ENABLE_WRITE(STATE) NOOP
  #define E3_ENABLE_READ (stepperE3.getStatus() & STATUS_HIZ)
  #define E3_DIR_INIT NOOP
  #define E3_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E3)
  #define E3_DIR_READ (stepperE3.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E3)
    extern TMC_CLASS(E3) stepperE3;
  #endif
  #if AXIS_DRIVER_TYPE_E3(TMC26X)
    extern TMC26XStepper stepperE3;
    #define E3_ENABLE_INIT NOOP
    #define E3_ENABLE_WRITE(STATE) stepperE3.setEnabled(STATE)
    #define E3_ENABLE_READ stepperE3.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
    #define E3_ENABLE_INIT NOOP
    #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E3_ENABLE_READ stepperE3.isEnabled()
  #else
    #define E3_ENABLE_INIT SET_OUTPUT(E3_ENABLE_PIN)
    #define E3_ENABLE_WRITE(STATE) WRITE(E3_ENABLE_PIN,STATE)
    #define E3_ENABLE_READ READ(E3_ENABLE_PIN)
  #endif
  #define E3_DIR_INIT SET_OUTPUT(E3_DIR_PIN)
  #define E3_DIR_WRITE(STATE) WRITE(E3_DIR_PIN,STATE)
  #define E3_DIR_READ READ(E3_DIR_PIN)
#endif
#define E3_STEP_INIT SET_OUTPUT(E3_STEP_PIN)
#if AXIS_IS_TMC(E3) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E3_STEP_WRITE(STATE) if (STATE) { TOGGLE(E3_STEP_PIN); }
#else
  #define E3_STEP_WRITE(STATE) WRITE(E3_STEP_PIN,STATE)
  #define E3_STEP_READ READ(E3_STEP_PIN)
#endif

// E4 Stepper
#if AXIS_DRIVER_TYPE_E4(L6470)
  extern L6470 stepperE4;
  #define E4_ENABLE_INIT NOOP
  #define E4_ENABLE_WRITE(STATE) NOOP
  #define E4_ENABLE_READ (stepperE4.getStatus() & STATUS_HIZ)
  #define E4_DIR_INIT NOOP
  #define E4_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E4)
  #define E4_DIR_READ (stepperE4.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E4)
    extern TMC_CLASS(E4) stepperE4;
  #endif
  #if AXIS_DRIVER_TYPE_E4(TMC26X)
    extern TMC26XStepper stepperE4;
    #define E4_ENABLE_INIT NOOP
    #define E4_ENABLE_WRITE(STATE) stepperE4.setEnabled(STATE)
    #define E4_ENABLE_READ stepperE4.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
    #define E4_ENABLE_INIT NOOP
    #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E4_ENABLE_READ stepperE4.isEnabled()
  #else
    #define E4_ENABLE_INIT SET_OUTPUT(E4_ENABLE_PIN)
    #define E4_ENABLE_WRITE(STATE) WRITE(E4_ENABLE_PIN,STATE)
    #define E4_ENABLE_READ READ(E4_ENABLE_PIN)
  #endif
  #define E4_DIR_INIT SET_OUTPUT(E4_DIR_PIN)
  #define E4_DIR_WRITE(STATE) WRITE(E4_DIR_PIN,STATE)
  #define E4_DIR_READ READ(E4_DIR_PIN)
#endif
#define E4_STEP_INIT SET_OUTPUT(E4_STEP_PIN)
#if AXIS_IS_TMC(E4) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E4_STEP_WRITE(STATE) if (STATE) { TOGGLE(E4_STEP_PIN); }
#else
  #define E4_STEP_WRITE(STATE) WRITE(E4_STEP_PIN,STATE)
  #define E4_STEP_READ READ(E4_STEP_PIN)
#endif

// E5 Stepper
#if AXIS_DRIVER_TYPE_E5(L6470)
  extern L6470 stepperE5;
  #define E5_ENABLE_INIT NOOP
  #define E5_ENABLE_WRITE(STATE) NOOP
  #define E5_ENABLE_READ (stepperE5.getStatus() & STATUS_HIZ)
  #define E5_DIR_INIT NOOP
  #define E5_DIR_WRITE(STATE) L6470_WRITE_DIR_COMMAND(STATE,E5)
  #define E5_DIR_READ (stepperE5.getStatus() & STATUS_DIR)
#else
  #if AXIS_IS_TMC(E5)
    extern TMC_CLASS(E5) stepperE5;
  #endif
  #if AXIS_DRIVER_TYPE_E5(TMC26X)
    extern TMC26XStepper stepperE5;
    #define E5_ENABLE_INIT NOOP
    #define E5_ENABLE_WRITE(STATE) stepperE5.setEnabled(STATE)
    #define E5_ENABLE_READ stepperE5.isEnabled()
  #elif ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
    #define E5_ENABLE_INIT NOOP
    #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
    #define E5_ENABLE_READ stepperE5.isEnabled()
  #else
    #define E5_ENABLE_INIT SET_OUTPUT(E5_ENABLE_PIN)
    #define E5_ENABLE_WRITE(STATE) WRITE(E5_ENABLE_PIN,STATE)
    #define E5_ENABLE_READ READ(E5_ENABLE_PIN)
  #endif
  #define E5_DIR_INIT SET_OUTPUT(E5_DIR_PIN)
  #define E5_DIR_WRITE(STATE) WRITE(E5_DIR_PIN,STATE)
  #define E5_DIR_READ READ(E5_DIR_PIN)
#endif
#define E5_STEP_INIT SET_OUTPUT(E5_STEP_PIN)
#if AXIS_IS_TMC(E5) && ENABLED(USE_BOTH_EDGES_STEP)
  #define E5_STEP_WRITE(STATE) if (STATE) { TOGGLE(E5_STEP_PIN); }
#else
  #define E5_STEP_WRITE(STATE) WRITE(E5_STEP_PIN,STATE)
  #define E5_STEP_READ READ(E5_STEP_PIN)
#endif

/**
 * Extruder indirection for the single E axis
 */
#if ENABLED(SWITCHING_EXTRUDER) // One stepper driver per two extruders, reversed on odd index
  #if EXTRUDERS > 5
    #define E_STEP_WRITE(E,V) do{ if (E < 2) { E0_STEP_WRITE(V); } else if (E < 4) { E1_STEP_WRITE(V); } else { E2_STEP_WRITE(V); } }while(0)
    #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E0_DIR_WRITE( INVERT_E0_DIR); break; case 2: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 3: E1_DIR_WRITE( INVERT_E1_DIR); break; case 4: E2_DIR_WRITE(!INVERT_E2_DIR); case 5: E2_DIR_WRITE( INVERT_E2_DIR); } }while(0)
    #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 2: E1_DIR_WRITE( INVERT_E1_DIR); break; case 3: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 4: E2_DIR_WRITE( INVERT_E2_DIR); case 5: E2_DIR_WRITE(!INVERT_E2_DIR); } }while(0)
  #elif EXTRUDERS > 4
    #define E_STEP_WRITE(E,V) do{ if (E < 2) { E0_STEP_WRITE(V); } else if (E < 4) { E1_STEP_WRITE(V); } else { E2_STEP_WRITE(V); } }while(0)
    #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E0_DIR_WRITE( INVERT_E0_DIR); break; case 2: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 3: E1_DIR_WRITE( INVERT_E1_DIR); break; case 4: E2_DIR_WRITE(!INVERT_E2_DIR); } }while(0)
    #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 2: E1_DIR_WRITE( INVERT_E1_DIR); break; case 3: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 4: E2_DIR_WRITE( INVERT_E2_DIR); } }while(0)
  #elif EXTRUDERS > 3
    #define E_STEP_WRITE(E,V) do{ if (E < 2) { E0_STEP_WRITE(V); } else { E1_STEP_WRITE(V); } }while(0)
    #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E0_DIR_WRITE( INVERT_E0_DIR); break; case 2: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 3: E1_DIR_WRITE( INVERT_E1_DIR); } }while(0)
    #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 2: E1_DIR_WRITE( INVERT_E1_DIR); break; case 3: E1_DIR_WRITE(!INVERT_E1_DIR); } }while(0)
  #elif EXTRUDERS > 2
    #define E_STEP_WRITE(E,V) do{ if (E < 2) { E0_STEP_WRITE(V); } else { E1_STEP_WRITE(V); } }while(0)
    #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E0_DIR_WRITE( INVERT_E0_DIR); break; case 2: E1_DIR_WRITE(!INVERT_E1_DIR); } }while(0)
    #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 2: E1_DIR_WRITE( INVERT_E1_DIR); } }while(0)
  #else
    #define E_STEP_WRITE(E,V) E0_STEP_WRITE(V)
    #define   NORM_E_DIR(E)   do{ E0_DIR_WRITE(E ?  INVERT_E0_DIR : !INVERT_E0_DIR); }while(0)
    #define    REV_E_DIR(E)   do{ E0_DIR_WRITE(E ? !INVERT_E0_DIR :  INVERT_E0_DIR); }while(0)
  #endif
#elif ENABLED(PRUSA_MMU2)
  #define E_STEP_WRITE(E,V) E0_STEP_WRITE(V)
  #define   NORM_E_DIR(E)   E0_DIR_WRITE(!INVERT_E0_DIR)
  #define    REV_E_DIR(E)   E0_DIR_WRITE( INVERT_E0_DIR)

#elif ENABLED(MK2_MULTIPLEXER) // One multiplexed stepper driver, reversed on odd index
  #define E_STEP_WRITE(E,V) E0_STEP_WRITE(V)
  #define   NORM_E_DIR(E)   do{ E0_DIR_WRITE(TEST(E, 0) ? !INVERT_E0_DIR:  INVERT_E0_DIR); }while(0)
  #define    REV_E_DIR(E)   do{ E0_DIR_WRITE(TEST(E, 0) ?  INVERT_E0_DIR: !INVERT_E0_DIR); }while(0)
#elif E_STEPPERS > 5
  #define E_STEP_WRITE(E,V) do{ switch (E) { case 0: E0_STEP_WRITE(V); break; case 1: E1_STEP_WRITE(V); break; case 2: E2_STEP_WRITE(V); break; case 3: E3_STEP_WRITE(V); break; case 4: E4_STEP_WRITE(V); case 5: E5_STEP_WRITE(V); } }while(0)
  #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 2: E2_DIR_WRITE(!INVERT_E2_DIR); break; case 3: E3_DIR_WRITE(!INVERT_E3_DIR); break; case 4: E4_DIR_WRITE(!INVERT_E4_DIR); case 5: E5_DIR_WRITE(!INVERT_E5_DIR); } }while(0)
  #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E1_DIR_WRITE( INVERT_E1_DIR); break; case 2: E2_DIR_WRITE( INVERT_E2_DIR); break; case 3: E3_DIR_WRITE( INVERT_E3_DIR); break; case 4: E4_DIR_WRITE( INVERT_E4_DIR); case 5: E5_DIR_WRITE( INVERT_E5_DIR); } }while(0)
#elif E_STEPPERS > 4
  #define E_STEP_WRITE(E,V) do{ switch (E) { case 0: E0_STEP_WRITE(V); break; case 1: E1_STEP_WRITE(V); break; case 2: E2_STEP_WRITE(V); break; case 3: E3_STEP_WRITE(V); break; case 4: E4_STEP_WRITE(V); } }while(0)
  #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 2: E2_DIR_WRITE(!INVERT_E2_DIR); break; case 3: E3_DIR_WRITE(!INVERT_E3_DIR); break; case 4: E4_DIR_WRITE(!INVERT_E4_DIR); } }while(0)
  #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E1_DIR_WRITE( INVERT_E1_DIR); break; case 2: E2_DIR_WRITE( INVERT_E2_DIR); break; case 3: E3_DIR_WRITE( INVERT_E3_DIR); break; case 4: E4_DIR_WRITE( INVERT_E4_DIR); } }while(0)
#elif E_STEPPERS > 3
  #define E_STEP_WRITE(E,V) do{ switch (E) { case 0: E0_STEP_WRITE(V); break; case 1: E1_STEP_WRITE(V); break; case 2: E2_STEP_WRITE(V); break; case 3: E3_STEP_WRITE(V); } }while(0)
  #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 2: E2_DIR_WRITE(!INVERT_E2_DIR); break; case 3: E3_DIR_WRITE(!INVERT_E3_DIR); } }while(0)
  #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E1_DIR_WRITE( INVERT_E1_DIR); break; case 2: E2_DIR_WRITE( INVERT_E2_DIR); break; case 3: E3_DIR_WRITE( INVERT_E3_DIR); } }while(0)
#elif E_STEPPERS > 2
  #define E_STEP_WRITE(E,V) do{ switch (E) { case 0: E0_STEP_WRITE(V); break; case 1: E1_STEP_WRITE(V); break; case 2: E2_STEP_WRITE(V); } }while(0)
  #define   NORM_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE(!INVERT_E0_DIR); break; case 1: E1_DIR_WRITE(!INVERT_E1_DIR); break; case 2: E2_DIR_WRITE(!INVERT_E2_DIR); } }while(0)
  #define    REV_E_DIR(E)   do{ switch (E) { case 0: E0_DIR_WRITE( INVERT_E0_DIR); break; case 1: E1_DIR_WRITE( INVERT_E1_DIR); break; case 2: E2_DIR_WRITE( INVERT_E2_DIR); } }while(0)
#elif E_STEPPERS > 1
  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)

    #define E_STEP_WRITE(E,V) do{ if (extruder_duplication_enabled)  { E0_STEP_WRITE(V); E1_STEP_WRITE(V); } \
                                                  else if ((E) == 0) { E0_STEP_WRITE(V); } \
                                                  else               { E1_STEP_WRITE(V); } }while(0)

    #define   NORM_E_DIR(E)   do{ if (extruder_duplication_enabled)  { E0_DIR_WRITE(!INVERT_E0_DIR); E1_DIR_WRITE(!INVERT_E1_DIR); } \
                                                  else if ((E) == 0) { E0_DIR_WRITE(!INVERT_E0_DIR); } \
                                                  else               { E1_DIR_WRITE(!INVERT_E1_DIR); } }while(0)

    #define    REV_E_DIR(E)   do{ if (extruder_duplication_enabled)  { E0_DIR_WRITE( INVERT_E0_DIR); E1_DIR_WRITE( INVERT_E1_DIR); } \
                                                  else if ((E) == 0) { E0_DIR_WRITE( INVERT_E0_DIR); } \
                                                  else               { E1_DIR_WRITE( INVERT_E1_DIR); } }while(0)
  #else
    #define E_STEP_WRITE(E,V) do{ if (E == 0) { E0_STEP_WRITE(V); } else { E1_STEP_WRITE(V); } }while(0)
    #define   NORM_E_DIR(E)   do{ if (E == 0) { E0_DIR_WRITE(!INVERT_E0_DIR); } else { E1_DIR_WRITE(!INVERT_E1_DIR); } }while(0)
    #define    REV_E_DIR(E)   do{ if (E == 0) { E0_DIR_WRITE( INVERT_E0_DIR); } else { E1_DIR_WRITE( INVERT_E1_DIR); } }while(0)
  #endif
#elif E_STEPPERS
  #define E_STEP_WRITE(E,V) E0_STEP_WRITE(V)
  #define   NORM_E_DIR(E)   E0_DIR_WRITE(!INVERT_E0_DIR)
  #define    REV_E_DIR(E)   E0_DIR_WRITE( INVERT_E0_DIR)
#else
  #define E_STEP_WRITE(E,V) NOOP
  #define   NORM_E_DIR(E)   NOOP
  #define    REV_E_DIR(E)   NOOP
#endif
