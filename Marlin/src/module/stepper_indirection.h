/**
 * Marlin 3D Printer Firmware
 * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

/**
 * stepper_indirection.h - stepper motor driver indirection macros
 * to allow some stepper functions to be done via SPI/I2c instead of direct pin manipulation
 * Part of Marlin
 *
 * Copyright (c) 2015 Dominik Wenger
 *
 * Marlin is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * at your option) any later version.
 *
 * Marlin is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Marlin.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "../inc/MarlinConfig.h"

// TMC26X drivers have STEP/DIR on normal pins, but ENABLE via SPI
#if HAS_DRIVER(TMC26X)
  #include <SPI.h>
  #ifdef STM32F7
    #include "../HAL/HAL_STM32F7/TMC2660.h"
  #else
    #include <TMC26XStepper.h>
  #endif
  void tmc26x_init_to_defaults();
#endif

#if HAS_TRINAMIC
  #include <TMCStepper.h>
  #include "../feature/tmc_util.h"
  #if TMCSTEPPER_VERSION < 0x000202
    #error "Update TMCStepper library to 0.2.2 or newer."
  #endif

  #define ____TMC_CLASS(MODEL, A, I) TMCMarlin<TMC##MODEL##Stepper, A, I>
  #define ___TMC_CLASS(MODEL, A, I) ____TMC_CLASS(MODEL, A, I)
  #define __TMC_CLASS(MODEL, A, I) ___TMC_CLASS(_##MODEL, A, I)
  #define _TMC_CLASS(MODEL, L) __TMC_CLASS(MODEL, L)
  #define TMC_CLASS(ST) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL)

  typedef struct {
    uint8_t toff;
    int8_t hend;
    uint8_t hstrt;
  } chopper_timing_t;

  static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;

  #if HAS_DRIVER(TMC2208)
    void tmc2208_serial_begin();
  #endif
#endif

void restore_stepper_drivers();  // Called by PSU_ON
void reset_stepper_drivers();    // Called by settings.load / settings.reset

// Driver models
#define _A4988_MODEL_REFERENCE(AXIS) 
#define _A4988_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
#define _A4988_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
#define _A4988_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
#define _A4988_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
#define _A4988_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
#define _A4988_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
#define _A4988_MODEL_DIR_CHANGE_DELAY 200
#define _A4988_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
#define _A4988_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
#define _A4988_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
#define _A4988_MODEL_STEP_SECOND_PHASE_NEED true
#define _A4988_MODEL_STEP_FIRST_PHASE_WIDTH 1
#define _A4988_MODEL_STEP_SECOND_PHASE_WIDTH 1
#if HAS_DRIVER(A5984)
  #define _A5984_MODEL_REFERENCE(AXIS) 
  #define _A5984_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _A5984_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _A5984_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _A5984_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _A5984_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _A5984_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _A5984_MODEL_DIR_CHANGE_DELAY 400
  #define _A5984_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _A5984_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _A5984_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _A5984_MODEL_STEP_SECOND_PHASE_NEED true
  #define _A5984_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _A5984_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(DRV8825)
  #define _DRV8825_MODEL_REFERENCE(AXIS) 
  #define _DRV8825_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _DRV8825_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _DRV8825_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _DRV8825_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _DRV8825_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _DRV8825_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _DRV8825_MODEL_DIR_CHANGE_DELAY 650
  #define _DRV8825_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _DRV8825_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _DRV8825_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _DRV8825_MODEL_STEP_SECOND_PHASE_NEED true
  #define _DRV8825_MODEL_STEP_FIRST_PHASE_WIDTH 2
  #define _DRV8825_MODEL_STEP_SECOND_PHASE_WIDTH 2
#endif
#if HAS_DRIVER(LV8729)
  #define _LV8729_MODEL_REFERENCE(AXIS) 
  #define _LV8729_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _LV8729_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _LV8729_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _LV8729_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _LV8729_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _LV8729_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _LV8729_MODEL_DIR_CHANGE_DELAY 500
  #define _LV8729_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _LV8729_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _LV8729_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _LV8729_MODEL_STEP_SECOND_PHASE_NEED true
  #define _LV8729_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _LV8729_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(L6470)
  // L6470 has STEP on normal pins, but DIR/ENABLE via SPI
  #include "L6470/L6470_Marlin.h"
  #define L6470_WRITE_DIR_COMMAND(STATE,Q) do{ L6470_dir_commands[Q] = (STATE ?  dSPIN_STEP_CLOCK_REV : dSPIN_STEP_CLOCK_FWD); }while(0)

  #define _L6470_MODEL_REFERENCE(AXIS) extern L6470 stepper##AXIS
  #define _L6470_MODEL_ENABLE_INIT(AXIS) NOOP
  #define _L6470_MODEL_ENABLE_WRITE(AXIS, STATE) NOOP
  #define _L6470_MODEL_ENABLE_READ(AXIS) (stepper##AXIS##.getStatus() & STATUS_HIZ)
  #define _L6470_MODEL_DIR_INIT(AXIS) NOOP
  #define _L6470_MODEL_DIR_WRITE(AXIS, STATE) L6470_WRITE_DIR_COMMAND(STATE,AXIS)
  #define _L6470_MODEL_DIR_READ(AXIS) (stepper##AXIS.getStatus() & STATUS_DIR)
  #define _L6470_MODEL_DIR_CHANGE_DELAY 0
  #define _L6470_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _L6470_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _L6470_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _L6470_MODEL_STEP_SECOND_PHASE_NEED true
  #define _L6470_MODEL_STEP_FIRST_PHASE_WIDTH 1
  #define _L6470_MODEL_STEP_SECOND_PHASE_WIDTH 1
#endif
#if HAS_DRIVER(TB6560)
  #define _TB6560_MODEL_REFERENCE(AXIS) 
  #define _TB6560_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TB6560_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TB6560_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TB6560_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TB6560_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TB6560_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _TB6560_MODEL_DIR_CHANGE_DELAY 15000
  #define _TB6560_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TB6560_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TB6560_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TB6560_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TB6560_MODEL_STEP_FIRST_PHASE_WIDTH 30
  #define _TB6560_MODEL_STEP_SECOND_PHASE_WIDTH 30
#endif
#if HAS_DRIVER(TB6600)
  #define _TB6600_MODEL_REFERENCE(AXIS) 
  #define _TB6600_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TB6600_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TB6600_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TB6600_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TB6600_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TB6600_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  // (guess, no info in datasheet)
  #define _TB6600_MODEL_DIR_CHANGE_DELAY 1500
  #define _TB6600_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TB6600_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TB6600_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TB6600_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TB6600_MODEL_STEP_FIRST_PHASE_WIDTH 3
  #define _TB6600_MODEL_STEP_SECOND_PHASE_WIDTH 3
#endif
#if HAS_DRIVER(TMC2100)
  #define _TMC2100_MODEL_REFERENCE(AXIS) 
  #define _TMC2100_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2100_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2100_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2100_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2100_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2100_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2100_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2100_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2100_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2100_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2100_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2100_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2100_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2130)
  #define __TMC2130_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2130_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2130_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2130_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2130_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2130_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2130_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2130_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2130_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2130_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2130_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2130_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2130_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2130_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2130_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2130_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2130_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2130_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2130_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2130_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2130_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2130_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2130_STANDALONE)
  #define _TMC2130_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2130_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2130_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2130_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2130_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2130_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2130_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2130_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2130_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2130_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2160)
  #define __TMC2160_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2160_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2160_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2160_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2160_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2160_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2160_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2160_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2160_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2160_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2160_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2160_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2160_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2160_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2160_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2160_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2160_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2160_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2160_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2160_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2160_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2160_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2160_STANDALONE)
  #define _TMC2160_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2160_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2160_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2160_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2160_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2160_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2160_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2160_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2160_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2160_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2208)
  #define __TMC2208_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2208_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2208_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2208_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2208_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2208_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2208_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2208_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2208_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2208_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2208_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2208_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2208_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2208_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2208_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2208_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2208_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2208_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2208_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2208_STANDALONE)
  #define _TMC2208_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2208_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2208_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2208_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2208_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2208_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2208_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2208_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2208_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2208_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC26X)
  #define _TMC26X_MODEL_REFERENCE(AXIS) extern TMC26XStepper stepper##AXIS
  #define _TMC26X_MODEL_ENABLE_INIT(AXIS) NOOP
  #define _TMC26X_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.setEnabled(STATE)
  #define _TMC26X_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #define _TMC26X_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC26X_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC26X_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC26X_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC26X_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC26X_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC26X_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC26X_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC26X_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC26X_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC26X_STANDALONE)
  #define _TMC26X_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC26X_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC26X_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC26X_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC26X_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC26X_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC26X_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC26X_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC26X_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC26X_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2660)
  #define __TMC2660_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC2660_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC2660_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC2660_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC2660_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC2660_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC2660_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC2660_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC2660_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC2660_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2660_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2660_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2660_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2660_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC2660_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC2660_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC2660_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC2660_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC2660_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC2660_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC2660_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2660_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC2660_STANDALONE)
  #define _TMC2660_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC2660_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC2660_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC2660_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC2660_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC2660_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC2660_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC2660_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC2660_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC2660_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5130)
  #define __TMC5130_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC5130_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC5130_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC5130_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC5130_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC5130_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC5130_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC5130_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC5130_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC5130_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5130_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5130_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5130_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5130_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC5130_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC5130_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC5130_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC5130_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC5130_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC5130_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC5130_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5130_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5130_STANDALONE)
  #define _TMC5130_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC5130_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC5130_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5130_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5130_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC5130_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC5130_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC5130_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC5130_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5130_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5160)
  #define __TMC5160_MODEL_REFERENCE(AXIS) stepper##AXIS
  #define _TMC5160_MODEL_REFERENCE(AXIS) extern TMC_CLASS(AXIS) __TMC5160_MODEL_REFERENCE(AXIS)
  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
    #define _TMC5160_MODEL_ENABLE_INIT(AXIS) NOOP
    #define _TMC5160_MODEL_ENABLE_WRITE(AXIS, STATE) stepper##AXIS##.toff((##STATE##)==##AXIS##_ENABLE_ON ? chopper_timing.toff : 0)
    #define _TMC5160_MODEL_ENABLE_READ(AXIS) stepper##AXIS.isEnabled()
  #else
    #define _TMC5160_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
    #define _TMC5160_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
    #define _TMC5160_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #endif
  #define _TMC5160_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5160_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5160_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5160_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5160_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #if ENABLED(USE_BOTH_EDGES_STEP)
    #define _TMC5160_MODEL_STEP_WRITE(AXIS, STATE) if (STATE) { TOGGLE(AXIS##_STEP_PIN); }
    #define _TMC5160_MODEL_STEP_READ(AXIS) NOOP
    #define _TMC5160_MODEL_STEP_SECOND_PHASE_NEED false
  #else
    #define _TMC5160_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
    #define _TMC5160_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
    #define _TMC5160_MODEL_STEP_SECOND_PHASE_NEED true
  #endif
  #define _TMC5160_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5160_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif
#if HAS_DRIVER(TMC5160_STANDALONE)
  #define _TMC5160_STANDALONE_MODEL_REFERENCE(AXIS) 
  #define _TMC5160_STANDALONE_MODEL_ENABLE_INIT(AXIS) SET_OUTPUT(AXIS##_ENABLE_PIN)
  #define _TMC5160_STANDALONE_MODEL_ENABLE_WRITE(AXIS, STATE) WRITE(AXIS##_ENABLE_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_ENABLE_READ(AXIS) READ(AXIS##_ENABLE_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_INIT(AXIS) SET_OUTPUT(AXIS##_DIR_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_WRITE(AXIS, STATE) WRITE(AXIS##_DIR_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_DIR_READ(AXIS) READ(AXIS##_DIR_PIN)
  #define _TMC5160_STANDALONE_MODEL_DIR_CHANGE_DELAY 20
  #define _TMC5160_STANDALONE_MODEL_STEP_INIT(AXIS) SET_OUTPUT(AXIS##_STEP_PIN)
  #define _TMC5160_STANDALONE_MODEL_STEP_WRITE(AXIS, STATE) WRITE(AXIS##_STEP_PIN,STATE)
  #define _TMC5160_STANDALONE_MODEL_STEP_READ(AXIS) READ(AXIS##_STEP_PIN)
  #define _TMC5160_STANDALONE_MODEL_STEP_SECOND_PHASE_NEED true
  #define _TMC5160_STANDALONE_MODEL_STEP_FIRST_PHASE_WIDTH 0
  #define _TMC5160_STANDALONE_MODEL_STEP_SECOND_PHASE_WIDTH 0
#endif

// Utility driver models macro
#ifdef X_DRIVER_TYPE
  #define ___X_DRIVER_TYPE X_DRIVER_TYPE
#else
  #define ___X_DRIVER_TYPE A4988
#endif
#ifdef Y_DRIVER_TYPE
  #define ___Y_DRIVER_TYPE Y_DRIVER_TYPE
#else
  #define ___Y_DRIVER_TYPE A4988
#endif
#ifdef Z_DRIVER_TYPE
  #define ___Z_DRIVER_TYPE Z_DRIVER_TYPE
#else
  #define ___Z_DRIVER_TYPE A4988
#endif
#ifdef X2_DRIVER_TYPE
  #define ___X2_DRIVER_TYPE X2_DRIVER_TYPE
#else
  #define ___X2_DRIVER_TYPE A4988
#endif
#ifdef Y2_DRIVER_TYPE
  #define ___Y2_DRIVER_TYPE Y_DRIVER_TYPE
#else
  #define ___Y2_DRIVER_TYPE A4988
#endif
#ifdef Z2_DRIVER_TYPE
  #define ___Z2_DRIVER_TYPE Z2_DRIVER_TYPE
#else
  #define ___Z2_DRIVER_TYPE A4988
#endif
#ifdef Z3_DRIVER_TYPE
  #define ___Z3_DRIVER_TYPE Z3_DRIVER_TYPE
#else
  #define ___Z3_DRIVER_TYPE A4988
#endif
#ifdef E0_DRIVER_TYPE
  #define ___E0_DRIVER_TYPE E0_DRIVER_TYPE
#else
  #define ___E0_DRIVER_TYPE A4988
#endif
#ifdef E1_DRIVER_TYPE
  #define ___E1_DRIVER_TYPE E1_DRIVER_TYPE
#else
  #define ___E1_DRIVER_TYPE A4988
#endif
#ifdef E2_DRIVER_TYPE
  #define ___E2_DRIVER_TYPE E2_DRIVER_TYPE
#else
  #define ___E2_DRIVER_TYPE A4988
#endif
#ifdef E3_DRIVER_TYPE
  #define ___E3_DRIVER_TYPE E3_DRIVER_TYPE
#else
  #define ___E3_DRIVER_TYPE A4988
#endif
#ifdef E4_DRIVER_TYPE
  #define ___E4_DRIVER_TYPE E4_DRIVER_TYPE
#else
  #define ___E4_DRIVER_TYPE A4988
#endif
#ifdef E5_DRIVER_TYPE
  #define ___E5_DRIVER_TYPE E5_DRIVER_TYPE
#else
  #define ___E5_DRIVER_TYPE A4988
#endif

#define _GET_AXIS_DRIVER_TYPE(AXIS) ___##AXIS##_DRIVER_TYPE
#define ___DRIVER_REFERENCE(TYPE) _ ## TYPE ## _MODEL_REFERENCE
#define ___MODEL_MACRO_NAME(TYPE, A, B) _ ## TYPE ## _MODEL_ ## A ## _ ## B
#ifdef MINIMUM_STEPPER_DIR_DELAY
  #define ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(DELAY) MAX(DELAY, MINIMUM_STEPPER_DIR_DELAY)
#else
  #define ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(DELAY) DELAY
#endif

#define __DRIVER_REFERENCE(TYPE, AXIS) ___DRIVER_REFERENCE(TYPE)(AXIS)
#define __DRIVER_ENABLE_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, ENABLE, INIT)(AXIS)
#define __DRIVER_ENABLE_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, ENABLE, WRITE)(AXIS, STATE)
#define __DRIVER_ENABLE_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, ENABLE, READ)(AXIS)
#define __DRIVER_DIR_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, INIT)(AXIS)
#define __DRIVER_DIR_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, DIR, WRITE)(AXIS, STATE)
#define __DRIVER_DIR_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, READ)(AXIS)
#define __DRIVER_DIR_CHANGE_DELAY(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, DIR, CHANGE_DELAY)
#define __DRIVER_STEP_INIT(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, STEP, INIT)(AXIS)
#define __DRIVER_STEP_WRITE(TYPE, AXIS, STATE) ___MODEL_MACRO_NAME(TYPE, STEP, WRITE)(AXIS, STATE)
#define __DRIVER_STEP_READ(TYPE, AXIS) ___MODEL_MACRO_NAME(TYPE, STEP, READ)(AXIS)
#define __DRIVER_STEP_FIRST_PHASE_WIDTH(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, FIRST_PHASE_WIDTH)
#define __DRIVER_STEP_SECOND_PHASE_WIDTH(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, SECOND_PHASE_WIDTH)
#define __DRIVER_STEP_SECOND_PHASE_NEED(TYPE) ___MODEL_MACRO_NAME(TYPE, STEP, SECOND_PHASE_NEED)

#define _DRIVER_REFERENCE(AXIS) __DRIVER_REFERENCE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_ENABLE_INIT(AXIS) __DRIVER_ENABLE_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_ENABLE_WRITE(AXIS, STATE) __DRIVER_ENABLE_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, STATE)
#define _DRIVER_ENABLE_READ(AXIS) __DRIVER_ENABLE_READ(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_INIT(AXIS) __DRIVER_DIR_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_WRITE(AXIS, STATE) __DRIVER_DIR_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, STATE)
#define _DRIVER_DIR_READ(AXIS) __DRIVER_DIR_READ(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_DIR_CHANGE_DELAY(AXIS) ___ENFORCE_MINIMUM_STEPPER_DIR_DELAY(__DRIVER_DIR_CHANGE_DELAY(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS))
#define _DRIVER_STEP_INIT(AXIS) __DRIVER_STEP_INIT(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS)
#define _DRIVER_STEP_PULSE_START(AXIS, INVERT) __DRIVER_STEP_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, !INVERT)
#define _DRIVER_STEP_PULSE_STOP(AXIS, INVERT) __DRIVER_STEP_WRITE(_GET_AXIS_DRIVER_TYPE(AXIS), AXIS, INVERT)
#define _DRIVER_STEP_FIRST_PHASE_WIDTH(AXIS) __DRIVER_STEP_FIRST_PHASE_WIDTH(_GET_AXIS_DRIVER_TYPE(AXIS))
#define _DRIVER_STEP_SECOND_PHASE_WIDTH(AXIS) __DRIVER_STEP_SECOND_PHASE_WIDTH(_GET_AXIS_DRIVER_TYPE(AXIS))
#define _DRIVER_STEP_SECOND_PHASE_NEED(AXIS) __DRIVER_STEP_SECOND_PHASE_NEED(_GET_AXIS_DRIVER_TYPE(AXIS))

// X Stepper
#define X_DRIVER_REFERENCE() _DRIVER_REFERENCE(X)
#define X_ENABLE_INIT() _DRIVER_ENABLE_INIT(X)
#define X_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(X, STATE)
#define X_ENABLE_READ() _DRIVER_ENABLE_READ(X)
#define X_DIR_INIT() _DRIVER_DIR_INIT(X)
#define X_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(X, STATE)
#define X_DIR_READ() _DRIVER_DIR_READ(X)
#define X_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(X)
#define X_STEP_INIT() _DRIVER_STEP_INIT(X)
#define X_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(X, INVERT)
#define X_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(X, INVERT)
#define X_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(X)
#define X_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(X)
#define X_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(X)
X_DRIVER_REFERENCE();

// Y Stepper
#define Y_DRIVER_REFERENCE() _DRIVER_REFERENCE(Y)
#define Y_ENABLE_INIT() _DRIVER_ENABLE_INIT(Y)
#define Y_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Y, STATE)
#define Y_ENABLE_READ() _DRIVER_ENABLE_READ(Y)
#define Y_DIR_INIT() _DRIVER_DIR_INIT(Y)
#define Y_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Y, STATE)
#define Y_DIR_READ() _DRIVER_DIR_READ(Y)
#define Y_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Y)
#define Y_STEP_INIT() _DRIVER_STEP_INIT(Y)
#define Y_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(Y, INVERT)
#define Y_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(Y, INVERT)
#define Y_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Y)
#define Y_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Y)
#define Y_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Y)
Y_DRIVER_REFERENCE();

// Z Stepper
#define Z_DRIVER_REFERENCE() _DRIVER_REFERENCE(Z)
#define Z_ENABLE_INIT() _DRIVER_ENABLE_INIT(Z)
#define Z_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z, STATE)
#define Z_ENABLE_READ() _DRIVER_ENABLE_READ(Z)
#define Z_DIR_INIT() _DRIVER_DIR_INIT(Z)
#define Z_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z, STATE)
#define Z_DIR_READ() _DRIVER_DIR_READ(Z)
#define Z_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z)
#define Z_STEP_INIT() _DRIVER_STEP_INIT(Z)
#define Z_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(Z, INVERT)
#define Z_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(Z, INVERT)
#define Z_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z)
#define Z_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z)
#define Z_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z)
Z_DRIVER_REFERENCE();

// X2 Stepper
#if HAS_X2_ENABLE
  #define X2_DRIVER_REFERENCE() _DRIVER_REFERENCE(X2)
  #define X2_ENABLE_INIT _DRIVER_ENABLE_INIT(X2)
  #define X2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(X2, STATE)
  #define X2_ENABLE_READ _DRIVER_ENABLE_READ(X2)
  #define X2_DIR_INIT _DRIVER_DIR_INIT(X2)
  #define X2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(X2, STATE)
  #define X2_DIR_READ _DRIVER_DIR_READ(X2)
  #define X2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(X2)
  #define X2_STEP_INIT _DRIVER_STEP_INIT(X2)
  #define X2_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(X2, INVERT)
  #define X2_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(X2, INVERT)
  #define X2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(X2)
  #define X2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(X2)
  #define X2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(X2)
  X2_DRIVER_REFERENCE();
#endif

// Y2 Stepper
#if HAS_Y2_ENABLE
  #define Y2_DRIVER_REFERENCE() _DRIVER_REFERENCE(Y2)
  #define Y2_ENABLE_INIT _DRIVER_ENABLE_INIT(Y2)
  #define Y2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Y2, STATE)
  #define Y2_ENABLE_READ _DRIVER_ENABLE_READ(Y2)
  #define Y2_DIR_INIT _DRIVER_DIR_INIT(Y2)
  #define Y2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Y2, STATE)
  #define Y2_DIR_READ _DRIVER_DIR_READ(Y2)
  #define Y2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Y2)
  #define Y2_STEP_INIT _DRIVER_STEP_INIT(Y2)
  #define Y2_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(Y2, INVERT)
  #define Y2_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(Y2, INVERT)
  #define Y2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Y2)
  #define Y2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Y2)
  #define Y2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Y2)
  Y2_DRIVER_REFERENCE();
#endif

// Z2 Stepper
#if HAS_Z2_ENABLE
  #define Z2_DRIVER_REFERENCE() _DRIVER_REFERENCE(Z2)
  #define Z2_ENABLE_INIT _DRIVER_ENABLE_INIT(Z2)
  #define Z2_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z2, STATE)
  #define Z2_ENABLE_READ _DRIVER_ENABLE_READ(Z2)
  #define Z2_DIR_INIT _DRIVER_DIR_INIT(Z2)
  #define Z2_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z2, STATE)
  #define Z2_DIR_READ _DRIVER_DIR_READ(Z2)
  #define Z2_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z2)
  #define Z2_STEP_INIT _DRIVER_STEP_INIT(Z2)
  #define Z2_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(Z2, INVERT)
  #define Z2_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(Z2, INVERT)
  #define Z2_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z2)
  #define Z2_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z2)
  #define Z2_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z2)
  Z2_DRIVER_REFERENCE();
#endif

// Z3 Stepper
#if HAS_Z3_ENABLE
  #define Z3_DRIVER_REFERENCE() _DRIVER_REFERENCE(Z3)
  #define Z3_ENABLE_INIT _DRIVER_ENABLE_INIT(Z3)
  #define Z3_ENABLE_WRITE(STATE) _DRIVER_ENABLE_WRITE(Z3, STATE)
  #define Z3_ENABLE_READ _DRIVER_ENABLE_READ(Z3)
  #define Z3_DIR_INIT _DRIVER_DIR_INIT(Z3)
  #define Z3_DIR_WRITE(STATE) _DRIVER_DIR_WRITE(Z3, STATE)
  #define Z3_DIR_READ _DRIVER_DIR_READ(Z3)
  #define Z3_DIR_CHANGE_DELAY _DRIVER_DIR_CHANGE_DELAY(Z3)
  #define Z3_STEP_INIT _DRIVER_STEP_INIT(Z3)
  #define Z3_STEP_PULSE_START(INVERT) _DRIVER_STEP_PULSE_START(Z3, INVERT)
  #define Z3_STEP_PULSE_STOP(INVERT) _DRIVER_STEP_PULSE_STOP(Z3, INVERT)
  #define Z3_STEP_FIRST_PHASE_WIDTH _DRIVER_STEP_FIRST_PHASE_WIDTH(Z3)
  #define Z3_STEP_SECOND_PHASE_WIDTH _DRIVER_STEP_SECOND_PHASE_WIDTH(Z3)
  #define Z3_STEP_SECOND_PHASE_NEED _DRIVER_STEP_SECOND_PHASE_NEED(Z3)
  Z3_DRIVER_REFERENCE();
#endif

// Ex Steppers
#define E_ENABLE_INIT(AXIS) _DRIVER_ENABLE_INIT(AXIS)
#define E_ENABLE_WRITE(AXIS, STATE) _DRIVER_ENABLE_WRITE(AXIS, STATE)
#define E_ENABLE_READ(AXIS) _DRIVER_ENABLE_READ(AXIS)
#define E_DIR_INIT(AXIS) _DRIVER_DIR_INIT(AXIS)
#define E_DIR_CHANGE_DELAY(AXIS) _DRIVER_DIR_CHANGE_DELAY(AXIS)
#define E_STEP_INIT(AXIS) _DRIVER_STEP_INIT(AXIS)
#define E_STEP_FIRST_PHASE_WIDTH(AXIS) _DRIVER_STEP_FIRST_PHASE_WIDTH(AXIS)
#define E_STEP_SECOND_PHASE_WIDTH(AXIS) _DRIVER_STEP_SECOND_PHASE_WIDTH(AXIS)
#define E_STEP_SECOND_PHASE_NEED(AXIS) _DRIVER_STEP_SECOND_PHASE_NEED(AXIS)

#if E_STEPPERS
  _DRIVER_REFERENCE(E0);
#endif
#if E_STEPPERS > 1
  _DRIVER_REFERENCE(E1);
#endif
#if E_STEPPERS > 2
  _DRIVER_REFERENCE(E2);
#endif
#if E_STEPPERS > 3
  _DRIVER_REFERENCE(E3);
#endif
#if E_STEPPERS > 4
  _DRIVER_REFERENCE(E4);
#endif
#if E_STEPPERS > 5
  _DRIVER_REFERENCE(E5);
#endif

/**
 * Extruder indirection for the single E axis
 */
#if ENABLED(SWITCHING_EXTRUDER) // One stepper driver per two extruders, reversed on odd index
  #if EXTRUDERS > 5
    #define E_STEP_PULSE_START(E) do{ if (E < 2) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } else if (E < 4) { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } else { _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (E < 2) {  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } else if (E < 4) {  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } else {  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 4: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); break; case 5: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 4: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); break; case 5: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); } }while(0)
  #elif EXTRUDERS > 4
    #define E_STEP_PULSE_START(E) do{ if (E < 2) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } else if (E < 4) { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } else { _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (E < 2) {  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } else if (E < 4) {  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } else {  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 4: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 4: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); } }while(0)
  #elif EXTRUDERS > 3
    #define E_STEP_PULSE_START(E) do{ if (E < 2) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } else { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (E < 2) {  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } else {  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 3: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); } }while(0)
  #elif EXTRUDERS > 2
    #define E_STEP_PULSE_START(E) do{ if (E < 2) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } else { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (E < 2) {  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } else {  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 2: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); } }while(0)
  #else
    #define E_STEP_PULSE_START(E) _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN)
    #define  E_STEP_PULSE_STOP(E) _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN)
    #define         NORM_E_DIR(E) _DRIVER_DIR_WRITE(E0, (TEST(E, 0) ? !INVERT_E0_DIR:  INVERT_E0_DIR))
    #define          REV_E_DIR(E) _DRIVER_DIR_WRITE(E0, (TEST(E, 0) ?  INVERT_E0_DIR: !INVERT_E0_DIR))
  #endif
#elif ENABLED(PRUSA_MMU2)
  #define E_STEP_PULSE_START(E) _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN)
  #define  E_STEP_PULSE_STOP(E) _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN)
  #define         NORM_E_DIR(E) _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR)
  #define          REV_E_DIR(E) _DRIVER_DIR_WRITE(E0, INVERT_E0_DIR)
#elif ENABLED(MK2_MULTIPLEXER) // One multiplexed stepper driver, reversed on odd index
  #define E_STEP_PULSE_START(E) _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN)
  #define  E_STEP_PULSE_STOP(E) _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN)
  #define         NORM_E_DIR(E) _DRIVER_DIR_WRITE(E0, (TEST(E, 0) ? !INVERT_E0_DIR:  INVERT_E0_DIR))
  #define          REV_E_DIR(E) _DRIVER_DIR_WRITE(E0, (TEST(E, 0) ?  INVERT_E0_DIR: !INVERT_E0_DIR))
#elif E_STEPPERS > 5
  #define E_STEP_PULSE_START(E) do{ switch (E) { case 0: _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); break; case 1: _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); break; case 2: _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); break; case 3: _DRIVER_STEP_PULSE_START(E3, INVERT_E_STEP_PIN); break; case 4: _DRIVER_STEP_PULSE_START(E4, INVERT_E_STEP_PIN); case 5: _DRIVER_STEP_PULSE_START(E5, INVERT_E_STEP_PIN); } }while(0)
  #define  E_STEP_PULSE_STOP(E) do{ switch (E) { case 0:  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); break; case 1:  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); break; case 2:  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); break; case 3:  _DRIVER_STEP_PULSE_STOP(E3, INVERT_E_STEP_PIN); break; case 4:  _DRIVER_STEP_PULSE_STOP(E4, INVERT_E_STEP_PIN); case 5:  _DRIVER_STEP_PULSE_STOP(E5, INVERT_E_STEP_PIN); } }while(0)
  #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3, !INVERT_E3_DIR); break; case 4: _DRIVER_DIR_WRITE(E4, !INVERT_E4_DIR); case 5: _DRIVER_DIR_WRITE(E5, !INVERT_E5_DIR); } }while(0)
  #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3,  INVERT_E3_DIR); break; case 4: _DRIVER_DIR_WRITE(E4,  INVERT_E4_DIR); case 5: _DRIVER_DIR_WRITE(E5,  INVERT_E5_DIR); } }while(0)
#elif E_STEPPERS > 4
  #define E_STEP_PULSE_START(E) do{ switch (E) { case 0: _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); break; case 1: _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); break; case 2: _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); break; case 3: _DRIVER_STEP_PULSE_START(E3, INVERT_E_STEP_PIN); break; case 4: _DRIVER_STEP_PULSE_START(E4, INVERT_E_STEP_PIN); } }while(0)
  #define  E_STEP_PULSE_STOP(E) do{ switch (E) { case 0:  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); break; case 1:  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); break; case 2:  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); break; case 3:  _DRIVER_STEP_PULSE_STOP(E3, INVERT_E_STEP_PIN); break; case 4:  _DRIVER_STEP_PULSE_STOP(E4, INVERT_E_STEP_PIN); } }while(0)
  #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3, !INVERT_E3_DIR); break; case 4: _DRIVER_DIR_WRITE(E4, !INVERT_E4_DIR); } }while(0)
  #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3,  INVERT_E3_DIR); break; case 4: _DRIVER_DIR_WRITE(E4,  INVERT_E4_DIR); } }while(0)
#elif E_STEPPERS > 3
  #define E_STEP_PULSE_START(E) do{ switch (E) { case 0: _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); break; case 1: _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); break; case 2: _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); break; case 3: _DRIVER_STEP_PULSE_START(E3, INVERT_E_STEP_PIN); } }while(0)
  #define  E_STEP_PULSE_STOP(E) do{ switch (E) { case 0:  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); break; case 1:  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); break; case 2:  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); break; case 3:  _DRIVER_STEP_PULSE_STOP(E3, INVERT_E_STEP_PIN); } }while(0)
  #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3, !INVERT_E3_DIR); } }while(0)
  #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); break; case 3: _DRIVER_DIR_WRITE(E3,  INVERT_E3_DIR); } }while(0)
#elif E_STEPPERS > 2
  #define E_STEP_PULSE_START(E) do{ switch (E) { case 0: _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); break; case 1: _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); break; case 2: _DRIVER_STEP_PULSE_START(E2, INVERT_E_STEP_PIN); } }while(0)
  #define  E_STEP_PULSE_STOP(E) do{ switch (E) { case 0:  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); break; case 1:  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); break; case 2:  _DRIVER_STEP_PULSE_STOP(E2, INVERT_E_STEP_PIN); } }while(0)
  #define         NORM_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2, !INVERT_E2_DIR); } }while(0)
  #define          REV_E_DIR(E) do{ switch (E) { case 0: _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); break; case 1: _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); break; case 2: _DRIVER_DIR_WRITE(E2,  INVERT_E2_DIR); } }while(0)
#elif E_STEPPERS > 1
  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)

    #define E_STEP_PULSE_START(E) do{ if (extruder_duplication_enabled)  { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } \
                                                      else if ((E) == 0) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } \
                                                      else               { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (extruder_duplication_enabled)  { _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } \
                                                      else if ((E) == 0) { _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } \
                                                      else               { _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ if (extruder_duplication_enabled)  { _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); } \
                                                      else if ((E) == 0) { _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); } \
                                                      else               { _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ if (extruder_duplication_enabled)  { _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); } \
                                                      else if ((E) == 0) { _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); } \
                                                      else               { _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); } }while(0)
  #else
    #define E_STEP_PULSE_START(E) do{ if (E == 0) { _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN); } else { _DRIVER_STEP_PULSE_START(E1, INVERT_E_STEP_PIN); } }while(0)
    #define  E_STEP_PULSE_STOP(E) do{ if (E == 0) {  _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN); } else {  _DRIVER_STEP_PULSE_STOP(E1, INVERT_E_STEP_PIN); } }while(0)
    #define         NORM_E_DIR(E) do{ if (E == 0) { _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR); } else { _DRIVER_DIR_WRITE(E1, !INVERT_E1_DIR); } }while(0)
    #define          REV_E_DIR(E) do{ if (E == 0) { _DRIVER_DIR_WRITE(E0,  INVERT_E0_DIR); } else { _DRIVER_DIR_WRITE(E1,  INVERT_E1_DIR); } }while(0)
  #endif
#elif E_STEPPERS
  #define E_STEP_PULSE_START(E) _DRIVER_STEP_PULSE_START(E0, INVERT_E_STEP_PIN)
  #define  E_STEP_PULSE_STOP(E) _DRIVER_STEP_PULSE_STOP(E0, INVERT_E_STEP_PIN)
  #define         NORM_E_DIR(E) _DRIVER_DIR_WRITE(E0, !INVERT_E0_DIR)
  #define          REV_E_DIR(E) _DRIVER_DIR_WRITE(E0, INVERT_E0_DIR)
#else
  #define E_STEP_PULSE_START(E) NOOP
  #define  E_STEP_PULSE_STOP(E) NOOP
  #define         NORM_E_DIR(E) NOOP
  #define          REV_E_DIR(E) NOOP
#endif
